//! Entity generation for SeaORM models
//!
//! This module generates the main entity struct with SeaORM 2.0 dense format.

use crate::options::{parse_field_options, parse_message_options, seaorm};
use crate::types::map_proto_type;
use crate::GeneratorError;
use heck::ToSnakeCase;
use prost_types::compiler::code_generator_response::File;
use prost_types::field_descriptor_proto::Label;
use prost_types::{DescriptorProto, FieldDescriptorProto, FileDescriptorProto};
use quote::{format_ident, quote};

/// Generate a SeaORM entity file from a protobuf message
pub fn generate(
    file: &FileDescriptorProto,
    message: &DescriptorProto,
) -> Result<Option<File>, GeneratorError> {
    // Check if this message has SeaORM options
    let message_options = match parse_message_options(message) {
        Some(opts) => opts,
        None => return Ok(None), // No seaorm options, skip this message
    };

    // Skip if explicitly marked
    if message_options.skip {
        return Ok(None);
    }

    // Get message name
    let message_name = message
        .name
        .as_ref()
        .ok_or_else(|| GeneratorError::CodeGenError("Message has no name".to_string()))?;

    // Determine table name
    let table_name = if message_options.table_name.is_empty() {
        message_name.to_snake_case()
    } else {
        message_options.table_name.clone()
    };

    // Generate the output filename
    let module_name = message_name.to_snake_case();
    let output_filename = format!(
        "{}/{}.rs",
        file.package.as_deref().unwrap_or("").replace('.', "/"),
        module_name
    );

    // Generate field definitions
    let fields = generate_fields(message)?;

    // Build the entity struct
    let struct_name = format_ident!("Model");
    let table_name_lit = &table_name;

    let field_tokens: Vec<_> = fields
        .iter()
        .map(|f| {
            let name = format_ident!("{}", f.name);
            let ty: proc_macro2::TokenStream = f.rust_type.parse().unwrap_or_else(|_| {
                let ty_ident = format_ident!("{}", f.rust_type);
                quote! { #ty_ident }
            });

            let attrs = &f.attributes;
            if attrs.is_empty() {
                quote! {
                    pub #name: #ty
                }
            } else {
                let attr_tokens: Vec<proc_macro2::TokenStream> = attrs
                    .iter()
                    .map(|a| {
                        let attr_content: proc_macro2::TokenStream = a.parse().unwrap();
                        quote! { #[sea_orm(#attr_content)] }
                    })
                    .collect();
                quote! {
                    #(#attr_tokens)*
                    pub #name: #ty
                }
            }
        })
        .collect();

    let code = quote! {
        //! SeaORM entity for `#table_name_lit` table
        //!
        //! Generated by protoc-gen-seaorm from protobuf definition.

        use sea_orm::entity::prelude::*;

        #[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
        #[sea_orm(table_name = #table_name_lit)]
        pub struct #struct_name {
            #(#field_tokens),*
        }

        #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
        pub enum Relation {}

        impl ActiveModelBehavior for ActiveModel {}
    };

    // Format the generated code
    let content = code.to_string();

    // Try to format with prettyplease if we can parse it
    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content, // If parsing fails, use unformatted
    };

    Ok(Some(File {
        name: Some(output_filename),
        content: Some(formatted),
        ..Default::default()
    }))
}

/// Generated field information
struct GeneratedField {
    name: String,
    rust_type: String,
    attributes: Vec<String>,
}

/// Generate field definitions from message fields
fn generate_fields(message: &DescriptorProto) -> Result<Vec<GeneratedField>, GeneratorError> {
    let mut fields = Vec::new();

    for field in &message.field {
        let field_name = field
            .name
            .as_ref()
            .ok_or_else(|| GeneratorError::CodeGenError("Field has no name".to_string()))?;

        // Get field options
        let field_options = parse_field_options(field);

        // Skip relation fields (they're handled separately)
        if is_relation_field(&field_options) {
            continue;
        }

        // Determine the Rust type
        let proto_type = field.r#type();
        let type_name = field.type_name.as_deref();
        let mapped = map_proto_type(proto_type, type_name);

        // Check if the field is nullable
        let is_nullable = is_field_nullable(field, &field_options);

        // Build the final Rust type
        let rust_type = if is_nullable && !mapped.rust_type.starts_with("Option<") {
            format!("Option<{}>", mapped.rust_type)
        } else {
            mapped.rust_type.clone()
        };

        // Override type if specified in options
        let rust_type = if let Some(ref opts) = field_options {
            if !opts.column_type.is_empty() {
                map_column_type_to_rust(&opts.column_type, is_nullable)
            } else {
                rust_type
            }
        } else {
            rust_type
        };

        // Generate attributes
        let attributes = generate_field_attributes(field_name, &field_options, &mapped);

        // Use snake_case for field name
        let snake_name = field_name.to_snake_case();

        fields.push(GeneratedField {
            name: snake_name,
            rust_type,
            attributes,
        });
    }

    Ok(fields)
}

/// Check if a field is a relation field
fn is_relation_field(options: &Option<seaorm::FieldOptions>) -> bool {
    if let Some(opts) = options {
        !opts.has_one.is_empty()
            || !opts.has_many.is_empty()
            || !opts.belongs_to.is_empty()
            || !opts.has_many_via.is_empty()
    } else {
        false
    }
}

/// Determine if a field should be nullable
fn is_field_nullable(field: &FieldDescriptorProto, options: &Option<seaorm::FieldOptions>) -> bool {
    // Check explicit nullable option
    if let Some(ref opts) = options {
        if opts.nullable {
            return true;
        }
    }

    // In proto3, all fields are implicitly optional (except repeated)
    // Check if it's not a repeated field
    let label = field.label();
    if label == Label::Repeated {
        return false;
    }

    // Check if it's proto3 optional
    field.proto3_optional.unwrap_or(false)
}

/// Generate SeaORM attributes for a field
fn generate_field_attributes(
    _field_name: &str,
    options: &Option<seaorm::FieldOptions>,
    _mapped: &crate::types::MappedType,
) -> Vec<String> {
    let mut attrs = Vec::new();

    if let Some(ref opts) = options {
        if opts.primary_key {
            if opts.auto_increment {
                attrs.push("primary_key".to_string());
            } else {
                attrs.push("primary_key, auto_increment = false".to_string());
            }
        }

        if opts.unique {
            attrs.push("unique".to_string());
        }

        if !opts.column_name.is_empty() {
            attrs.push(format!("column_name = \"{}\"", opts.column_name));
        }

        if !opts.column_type.is_empty() {
            attrs.push(format!("column_type = \"{}\"", opts.column_type));
        }

        if !opts.default_value.is_empty() {
            attrs.push(format!("default_value = \"{}\"", opts.default_value));
        }
    }

    attrs
}

/// Map a SeaORM column type string to a Rust type
fn map_column_type_to_rust(column_type: &str, is_nullable: bool) -> String {
    let base_type = match column_type.to_lowercase().as_str() {
        "uuid" => "Uuid",
        "json" | "jsonb" => "Json",
        "text" => "String",
        "integer" | "int" => "i32",
        "bigint" | "biginteger" => "i64",
        "smallint" | "smallinteger" => "i16",
        "float" => "f32",
        "double" => "f64",
        "decimal" => "Decimal",
        "boolean" | "bool" => "bool",
        "date" => "Date",
        "time" => "Time",
        "datetime" => "DateTime",
        "timestamp" | "timestampwithtimezone" => "DateTimeUtc",
        "binary" | "blob" | "varbinary" => "Vec<u8>",
        _ => column_type, // Use as-is if unknown
    };

    if is_nullable {
        format!("Option<{}>", base_type)
    } else {
        base_type.to_string()
    }
}
