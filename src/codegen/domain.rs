//! Domain type generation with garde validation
//!
//! This module generates domain types from protobuf messages that have
//! `seaorm.input` field options. The generated types include garde validation
//! attributes and TryFrom implementations for converting from proto requests.

use crate::options::{
    get_cached_input_message_options, get_cached_input_options, parse_input_message_options,
    parse_input_options, seaorm,
};
use crate::GeneratorError;
use heck::ToSnakeCase;
use proc_macro2::TokenStream;
use prost_types::compiler::code_generator_response::File;
use prost_types::{DescriptorProto, FieldDescriptorProto, FileDescriptorProto};
use quote::{format_ident, quote};

/// Generate a domain type from a protobuf message with input options
pub fn generate(
    file: &FileDescriptorProto,
    message: &DescriptorProto,
) -> Result<Option<File>, GeneratorError> {
    let file_name = file.name.as_deref().unwrap_or("");
    let message_name = message.name.as_deref().unwrap_or("");

    // Check if this message has input_message options
    // First try cached options (from preprocessed request bytes)
    // Then fallback to parsing from uninterpreted options (for tests)
    let input_message_opts = get_cached_input_message_options(file_name, message_name)
        .or_else(|| parse_input_message_options(message));

    // Check if any field has input options
    let has_input_fields = message.field.iter().any(|f| {
        get_cached_input_options(file_name, message_name, f.number.unwrap_or(0)).is_some()
            || parse_input_options(f).is_some()
    });

    // Skip if no input options found
    if input_message_opts.is_none() && !has_input_fields {
        return Ok(None);
    }

    let input_message_opts = input_message_opts.unwrap_or_default();

    // Skip if explicitly marked
    if input_message_opts.skip {
        return Ok(None);
    }

    // Determine domain type name
    let domain_type_name = if input_message_opts.domain_type.is_empty() {
        // Default: strip common suffixes like "Request", "Params", "Input"
        strip_request_suffix(message_name)
    } else {
        input_message_opts.domain_type.clone()
    };

    // Generate the output filename
    let module_name = domain_type_name.to_snake_case();
    let output_filename = format!(
        "{}/{}.rs",
        file.package.as_deref().unwrap_or("").replace('.', "/"),
        module_name
    );

    // Generate domain struct fields and validation attributes
    let (field_tokens, try_from_conversions) =
        generate_domain_fields(file_name, message_name, &message.field)?;

    // Build the struct
    let struct_ident = format_ident!("{}", domain_type_name);
    let proto_ident = format_ident!("{}", message_name);

    // Build doc comments
    let struct_doc = format!("Domain type for {}", message_name);

    let code = if input_message_opts.generate_try_from {
        quote! {
            //! Domain type generated from protobuf message
            //!
            //! Generated by protoc-gen-seaorm with garde validation.
            //! @generated

            #[allow(unused_imports)]
            use super::prelude::*;
            use garde::Validate;

            /// Validation/conversion error for domain types
            #[derive(Debug, thiserror::Error)]
            pub enum DomainError {
                /// Validation failed
                #[error("validation error: {0}")]
                Validation(#[from] garde::Report),
                /// Type conversion failed
                #[error("conversion error: {0}")]
                Conversion(String),
            }

            #[doc = #struct_doc]
            #[derive(Debug, Clone, garde::Validate)]
            pub struct #struct_ident {
                #(#field_tokens),*
            }

            impl TryFrom<#proto_ident> for #struct_ident {
                type Error = DomainError;

                fn try_from(proto: #proto_ident) -> Result<Self, Self::Error> {
                    let domain = Self {
                        #(#try_from_conversions),*
                    };
                    domain.validate()?;
                    Ok(domain)
                }
            }
        }
    } else {
        quote! {
            //! Domain type generated from protobuf message
            //!
            //! Generated by protoc-gen-seaorm with garde validation.
            //! @generated

            #[allow(unused_imports)]
            use super::prelude::*;

            #[doc = #struct_doc]
            #[derive(Debug, Clone, garde::Validate)]
            pub struct #struct_ident {
                #(#field_tokens),*
            }
        }
    };

    // Format the generated code
    let content = code.to_string();

    // Try to format with prettyplease if we can parse it
    let formatted = match syn::parse_file(&content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => content,
    };

    Ok(Some(File {
        name: Some(output_filename),
        content: Some(formatted),
        ..Default::default()
    }))
}

/// Generate domain struct fields with garde validation attributes
fn generate_domain_fields(
    file_name: &str,
    message_name: &str,
    fields: &[FieldDescriptorProto],
) -> Result<(Vec<TokenStream>, Vec<TokenStream>), GeneratorError> {
    let mut field_tokens = Vec::new();
    let mut try_from_conversions = Vec::new();

    for field in fields {
        let field_number = field.number.unwrap_or(0);
        let field_name = field.name.as_deref().unwrap_or("");

        // Get input options for this field
        // First try cached options, then fallback to parsing from uninterpreted options
        let input_opts = get_cached_input_options(file_name, message_name, field_number)
            .or_else(|| parse_input_options(field));

        // Skip if marked to skip
        if input_opts.as_ref().map(|o| o.skip).unwrap_or(false) {
            continue;
        }

        // Determine field name in domain type
        let domain_field_name = input_opts
            .as_ref()
            .filter(|o| !o.rename.is_empty())
            .map(|o| o.rename.clone())
            .unwrap_or_else(|| field_name.to_snake_case());

        let field_ident = format_ident!("{}", domain_field_name);
        let proto_field_ident = format_ident!("{}", field_name.to_snake_case());

        // Determine Rust type
        let (rust_type, needs_conversion) = determine_rust_type(field, &input_opts);
        let type_tokens: TokenStream = rust_type.parse().unwrap_or_else(|_| quote!(String));

        // Generate garde validation attributes (pass field type for correct range type suffix)
        let garde_attrs = generate_garde_attributes(&input_opts, field.r#type());

        // Generate field token
        let field_token = if garde_attrs.is_empty() {
            quote! {
                #[garde(skip)]
                pub #field_ident: #type_tokens
            }
        } else {
            quote! {
                #(#garde_attrs)*
                pub #field_ident: #type_tokens
            }
        };
        field_tokens.push(field_token);

        // Generate TryFrom conversion
        let conversion = if needs_conversion {
            quote! {
                #field_ident: proto.#proto_field_ident.parse().map_err(|e| DomainError::Conversion(format!("{}: {}", stringify!(#field_ident), e)))?
            }
        } else {
            quote! {
                #field_ident: proto.#proto_field_ident
            }
        };
        try_from_conversions.push(conversion);
    }

    Ok((field_tokens, try_from_conversions))
}

/// Determine the Rust type for a field
fn determine_rust_type(
    field: &FieldDescriptorProto,
    input_opts: &Option<seaorm::InputOptions>,
) -> (String, bool) {
    // Check if a custom type is specified
    if let Some(opts) = input_opts {
        if !opts.r#type.is_empty() {
            // Custom type specified, needs conversion from string
            return (opts.r#type.clone(), true);
        }
    }

    // Use proto type mapping
    let proto_type = field.r#type();
    let base_type = match proto_type {
        prost_types::field_descriptor_proto::Type::Bool => "bool",
        prost_types::field_descriptor_proto::Type::Int32
        | prost_types::field_descriptor_proto::Type::Sint32
        | prost_types::field_descriptor_proto::Type::Sfixed32 => "i32",
        prost_types::field_descriptor_proto::Type::Int64
        | prost_types::field_descriptor_proto::Type::Sint64
        | prost_types::field_descriptor_proto::Type::Sfixed64 => "i64",
        prost_types::field_descriptor_proto::Type::Uint32
        | prost_types::field_descriptor_proto::Type::Fixed32 => "u32",
        prost_types::field_descriptor_proto::Type::Uint64
        | prost_types::field_descriptor_proto::Type::Fixed64 => "u64",
        prost_types::field_descriptor_proto::Type::Float => "f32",
        prost_types::field_descriptor_proto::Type::Double => "f64",
        prost_types::field_descriptor_proto::Type::String => "String",
        prost_types::field_descriptor_proto::Type::Bytes => "Vec<u8>",
        _ => "String",
    };

    (base_type.to_string(), false)
}

/// Generate garde validation attributes from input options
fn generate_garde_attributes(
    input_opts: &Option<seaorm::InputOptions>,
    field_type: prost_types::field_descriptor_proto::Type,
) -> Vec<TokenStream> {
    use prost_types::field_descriptor_proto::Type;

    let mut attrs = Vec::new();

    let Some(opts) = input_opts else {
        return attrs;
    };

    let Some(validate) = &opts.validate else {
        return attrs;
    };

    // Skip validation
    if validate.skip {
        attrs.push(quote!(#[garde(skip)]));
        return attrs;
    }

    // Email validation
    if validate.email {
        attrs.push(quote!(#[garde(email)]));
    }

    // URL validation
    if validate.url {
        attrs.push(quote!(#[garde(url)]));
    }

    // ASCII validation
    if validate.ascii {
        attrs.push(quote!(#[garde(ascii)]));
    }

    // Alphanumeric validation
    if validate.alphanumeric {
        attrs.push(quote!(#[garde(alphanumeric)]));
    }

    // Pattern/regex validation
    if !validate.pattern.is_empty() {
        let pattern = &validate.pattern;
        attrs.push(quote!(#[garde(pattern(#pattern))]));
    }

    // Length validation
    if let Some(length) = &validate.length {
        match (length.min, length.max) {
            (Some(min), Some(max)) => {
                attrs.push(quote!(#[garde(length(min = #min, max = #max))]));
            }
            (Some(min), None) => {
                attrs.push(quote!(#[garde(length(min = #min))]));
            }
            (None, Some(max)) => {
                attrs.push(quote!(#[garde(length(max = #max))]));
            }
            (None, None) => {}
        }
    }

    // Range validation - use correct type based on field type
    if let Some(range) = &validate.range {
        // Generate range with correct type suffix based on proto field type
        let range_attr = match field_type {
            Type::Int32 | Type::Sint32 | Type::Sfixed32 => {
                generate_range_attr_i32(range.min.map(|v| v as i32), range.max.map(|v| v as i32))
            }
            Type::Uint32 | Type::Fixed32 => {
                generate_range_attr_u32(range.min.map(|v| v as u32), range.max.map(|v| v as u32))
            }
            Type::Uint64 | Type::Fixed64 => {
                generate_range_attr_u64(range.min.map(|v| v as u64), range.max.map(|v| v as u64))
            }
            _ => {
                // Default to i64 for int64, sint64, sfixed64, and others
                generate_range_attr_i64(range.min, range.max)
            }
        };
        if let Some(attr) = range_attr {
            attrs.push(attr);
        }
    }

    // Custom validation
    if !validate.custom.is_empty() {
        let custom_fn: TokenStream = validate.custom.parse().unwrap_or_else(|_| quote!(validate));
        attrs.push(quote!(#[garde(custom(#custom_fn))]));
    }

    // Required validation (non-empty for strings)
    if validate.required {
        attrs.push(quote!(#[garde(length(min = 1))]));
    }

    attrs
}

fn generate_range_attr_i32(min: Option<i32>, max: Option<i32>) -> Option<TokenStream> {
    match (min, max) {
        (Some(min), Some(max)) => Some(quote!(#[garde(range(min = #min, max = #max))])),
        (Some(min), None) => Some(quote!(#[garde(range(min = #min))])),
        (None, Some(max)) => Some(quote!(#[garde(range(max = #max))])),
        (None, None) => None,
    }
}

fn generate_range_attr_u32(min: Option<u32>, max: Option<u32>) -> Option<TokenStream> {
    match (min, max) {
        (Some(min), Some(max)) => Some(quote!(#[garde(range(min = #min, max = #max))])),
        (Some(min), None) => Some(quote!(#[garde(range(min = #min))])),
        (None, Some(max)) => Some(quote!(#[garde(range(max = #max))])),
        (None, None) => None,
    }
}

fn generate_range_attr_i64(min: Option<i64>, max: Option<i64>) -> Option<TokenStream> {
    match (min, max) {
        (Some(min), Some(max)) => Some(quote!(#[garde(range(min = #min, max = #max))])),
        (Some(min), None) => Some(quote!(#[garde(range(min = #min))])),
        (None, Some(max)) => Some(quote!(#[garde(range(max = #max))])),
        (None, None) => None,
    }
}

fn generate_range_attr_u64(min: Option<u64>, max: Option<u64>) -> Option<TokenStream> {
    match (min, max) {
        (Some(min), Some(max)) => Some(quote!(#[garde(range(min = #min, max = #max))])),
        (Some(min), None) => Some(quote!(#[garde(range(min = #min))])),
        (None, Some(max)) => Some(quote!(#[garde(range(max = #max))])),
        (None, None) => None,
    }
}

/// Strip common request suffixes from message name
fn strip_request_suffix(name: &str) -> String {
    for suffix in &["Request", "Params", "Input", "Req"] {
        if let Some(stripped) = name.strip_suffix(suffix) {
            if !stripped.is_empty() {
                return stripped.to_string();
            }
        }
    }
    name.to_string()
}
